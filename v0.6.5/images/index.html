<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Working with Images in Julia · Augmentor.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/style.css" rel="stylesheet" type="text/css"/><link href="../democards/gridtheme.css" rel="stylesheet" type="text/css"/><link href="../democards/listtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Augmentor.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Augmentor.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started</a></li><li><span class="tocitem">Introduction and Motivation</span><ul><li><a class="tocitem" href="../background/">Background and Motivation</a></li><li class="is-active"><a class="tocitem" href>Working with Images in Julia</a><ul class="internal"><li><a class="tocitem" href="#Multi-dimensional-Arrays"><span>Multi-dimensional Arrays</span></a></li><li><a class="tocitem" href="#Vertical-Major-vs-Horizontal-Major"><span>Vertical-Major vs Horizontal-Major</span></a></li><li><a class="tocitem" href="#Reinterpreting-Elements"><span>Reinterpreting Elements</span></a></li><li><a class="tocitem" href="#Introduction-to-Color-Models"><span>Introduction to Color Models</span></a></li><li><a class="tocitem" href="#Fixed-Point-Numbers"><span>Fixed Point Numbers</span></a></li></ul></li></ul></li><li><span class="tocitem">User&#39;s Guide</span><ul><li><a class="tocitem" href="../interface/">High-level Interface</a></li><li><a class="tocitem" href="../operations/">Supported Operations</a></li></ul></li><li><span class="tocitem">Developer&#39;s Guide</span><ul><li><a class="tocitem" href="../wrappers/">Semantic Wrappers</a></li></ul></li><li><a class="tocitem" href="../examples/">Tutorials</a></li><li><a class="tocitem" href="../LICENSE/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Introduction and Motivation</a></li><li class="is-active"><a href>Working with Images in Julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Working with Images in Julia</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Evizero/Augmentor.jl/blob/master/docs/src/images.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Working-with-Images-in-Julia"><a class="docs-heading-anchor" href="#Working-with-Images-in-Julia">Working with Images in Julia</a><a id="Working-with-Images-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Images-in-Julia" title="Permalink"></a></h1><p>The <a href="https://julialang.org/">Julia language</a> provides a rich syntax as well as large set of highly-optimized functionality for working with (multi-dimensional) arrays of what is known as &quot;bit types&quot; or compositions of such. Because of this, the language lends itself particularly well to the fairly simple idea of treating images as just plain arrays. Even though this may sound as a rather tedious low-level approach, Julia makes it possible to still allow for powerful abstraction layers without the loss of generality that usually comes with that. This is accomplished with help of Julia&#39;s flexible type system and multiple dispatch (both of which are beyond the scope of this tutorial).</p><p>While the images-are-arrays-approach makes working with images in Julia very performant, it has also been source of confusion to new community members. This beginner&#39;s guide is an attempt to provide a step-by-step overview of how pixel data is handled in Julia. To get a more detailed explanation on some particular concept involved, please take a look at the documentation of the <a href="https://juliaimages.org/">JuliaImages</a> ecosystem.</p><h2 id="Multi-dimensional-Arrays"><a class="docs-heading-anchor" href="#Multi-dimensional-Arrays">Multi-dimensional Arrays</a><a id="Multi-dimensional-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-dimensional-Arrays" title="Permalink"></a></h2><p>To wrap our heads around Julia&#39;s array-based treatment of images, we first need to understand what Julia arrays are and how we can work with them.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This section is only intended provide a simplified and thus partial overview of Julia&#39;s arrays capabilities in order to gain some intuition about pixel data. For a more detailed treatment of the topic please have a look at the <a href="https://docs.julialang.org/en/latest/manual/arrays/">official documentation</a></p></div></div><p>Whenever we work with an <code>Array</code> in which the elements are bit-types (e.g. <code>Int64</code>, <code>Float32</code>, <code>UInt8</code>, etc), we can think of the array as a continuous block of memory. This is useful for many different reasons, such as cache locality and interacting with external libraries.</p><p>The same block of memory can be interpreted in a number of ways. Consider the following example in which we allocate a vector (i.e. a one dimensional array) of <code>UInt8</code> (i.e. bytes) with some ordered example values ranging from 1 to 6. We will think of this as our physical memory block, since it is a pretty close representation.</p><pre><code class="language-julia-repl">julia&gt; memory = [0x1, 0x2, 0x3, 0x4, 0x5, 0x6]
6-element Vector{UInt8}:
 0x01
 0x02
 0x03
 0x04
 0x05
 0x06</code></pre><p>The same block of memory could also be interpreted differently. For example we could think of this as a matrix with 3 rows and 2 columns instead (or even the other way around). The function <code>reshape</code> allows us to do just that</p><pre><code class="language-julia-repl">julia&gt; A = reshape(memory, (3, 2))
3×2 Matrix{UInt8}:
 0x01  0x04
 0x02  0x05
 0x03  0x06</code></pre><p>Note how we specified the number of rows first. This is because the Julia language follows the <a href="https://docs.julialang.org/en/latest/manual/performance-tips/#Access-arrays-in-memory-order,-along-columns-1">column-major convention</a> for multi dimensional arrays. What this means can be observed when we compare our new matrix <code>A</code> with the initial vector <code>memory</code> and look at the element layout. Both variables are using the same underlying memory (i.e the value <code>0x01</code> is physically stored right next to the value <code>0x02</code> in our example, while <code>0x01</code> and <code>0x04</code> are quite far apart even though the matrix interpretation makes it look like they are neighbors; which they are not).</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>A quick and dirty way to check if two variables are representing the same block of memory is by comparing the output of <code>pointer(myvariable)</code>. Note, however, that technically this only tells you where a variable starts in memory and thus has its limitations.</p></div></div><p>This idea can also be generalized for higher dimensions. For example we can think of this as a 3D array as well.</p><pre><code class="language-julia-repl">julia&gt; reshape(memory, (3, 1, 2))
3×1×2 Array{UInt8, 3}:
[:, :, 1] =
 0x01
 0x02
 0x03

[:, :, 2] =
 0x04
 0x05
 0x06</code></pre><p>If you take a closer look at the dimension sizes, you can see that all we did in that example was add a new dimension of size <code>1</code>, while not changing the other numbers. In fact we can add any number of practically empty dimensions, otherwise known as <em>singleton dimensions</em>.</p><pre><code class="language-julia-repl">julia&gt; reshape(memory, (3,1,1,1,2))
3×1×1×1×2 Array{UInt8, 5}:
[:, :, 1, 1, 1] =
 0x01
 0x02
 0x03

[:, :, 1, 1, 2] =
 0x04
 0x05
 0x06</code></pre><p>This is a useful property to have when we are confronted with greyscale datasets that do not have a color channel, yet we still want to work with a library that expects the images to have one.</p><h2 id="Vertical-Major-vs-Horizontal-Major"><a class="docs-heading-anchor" href="#Vertical-Major-vs-Horizontal-Major">Vertical-Major vs Horizontal-Major</a><a id="Vertical-Major-vs-Horizontal-Major-1"></a><a class="docs-heading-anchor-permalink" href="#Vertical-Major-vs-Horizontal-Major" title="Permalink"></a></h2><p>There are a number of different conventions for how to store image data into a binary format. The first question one has to address is the order in which the image dimensions are transcribed.</p><p>We have seen before that Julia follows the column-major convention for its arrays, which for images would lead to the corresponding convention of being vertical-major. In the image domain, however, it is fairly common to store the pixels in a horizontal-major layout. In other words, horizontal-major means that images are stored in memory (or file) one pixel row after the other.</p><p>In most cases, when working within the JuliaImages ecosystem, the images should already be in the Julia-native column major layout. If for some reason that is not the case there are two possible ways to convert the image to that format.</p><pre><code class="language-julia-repl">julia&gt; At = collect(reshape(memory, (3,2))&#39;) # &quot;row-major&quot; layout
2×3 Matrix{UInt8}:
 0x01  0x02  0x03
 0x04  0x05  0x06</code></pre><ol><li><p>The first way to alter the pixel order is by using the function <code>Base.permutedims</code>. In contrast to what we have seen before, this function will allocate a new array and copy the values in the appropriate manner.</p><pre><code class="language-julia-repl">julia&gt; B = permutedims(At, (2,1))
3×2 Matrix{UInt8}:
 0x01  0x04
 0x02  0x05
 0x03  0x06</code></pre></li><li><p>The second way is using <code>Base.PermutedDimsArray</code> which results in a lazy view that does not allocate a new array but instead only computes the correct values when queried.</p><pre><code class="language-julia-repl">julia&gt; C = PermutedDimsArray(At, (2,1))
3×2 PermutedDimsArray(::Matrix{UInt8}, (2, 1)) with eltype UInt8:
 0x01  0x04
 0x02  0x05
 0x03  0x06</code></pre></li></ol><p>Either way, it is in general a good idea to make sure that the array one is working with ends up in a column-major layout.</p><h2 id="Reinterpreting-Elements"><a class="docs-heading-anchor" href="#Reinterpreting-Elements">Reinterpreting Elements</a><a id="Reinterpreting-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Reinterpreting-Elements" title="Permalink"></a></h2><p>Up to this point, all we talked about was how to reinterpreting or permuting the dimensional layout of some continuous memory block. If you look at the examples above you will see that all the arrays have elements of type <code>UInt8</code>, which just means that each element is represented by a single byte in memory.</p><p>Knowing all this, we can now take the idea a step further and think about reinterpreting the element types of the array. Let us consider our original vector <code>memory</code> again.</p><pre><code class="language-julia-repl">julia&gt; memory = [0x1, 0x2, 0x3, 0x4, 0x5, 0x6]
6-element Vector{UInt8}:
 0x01
 0x02
 0x03
 0x04
 0x05
 0x06</code></pre><p>Note how each byte is thought of as an individual element. One thing we could do instead, is think of this memory block as a vector of 3 <code>UInt16</code> elements.</p><pre><code class="language-julia-repl">julia&gt; reinterpret(UInt16, memory)
3-element reinterpret(UInt16, ::Vector{UInt8}):
 0x0201
 0x0403
 0x0605</code></pre><p>Pay attention to where our original bytes ended up. In contrast to just rearranging elements as we did before, we ended up with significantly different element values. One may ask why it would ever be practical to reinterpret a memory block like this. The one word answer to this is <strong>Colors</strong>! As we will see in the remainder of this tutorial, it turns out to be a very useful thing to do when your arrays represent pixel data.</p><h2 id="Introduction-to-Color-Models"><a class="docs-heading-anchor" href="#Introduction-to-Color-Models">Introduction to Color Models</a><a id="Introduction-to-Color-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Color-Models" title="Permalink"></a></h2><p>As we discussed before, there are a various number of conventions on how to store pixel data into a binary format. That is not only true for dimension priority, but also for color information.</p><p>One way color information can differ is in the <a href="https://en.wikipedia.org/wiki/Color_model">color model</a> in which they are described in. Two famous examples for color models are <em>RGB</em> and <em>HSV</em>. They essentially define how colors are conceptually made up in terms of some components. Additionally, one can decide on how many bits to use to describe each color component. By doing so one defines the available <a href="https://en.wikipedia.org/wiki/Color_depth">color depth</a>.</p><p>Before we look into using the actual implementation of Julia&#39;s color models, let us prototype our own imperfect toy model in order to get a better understanding of what is happening under the hood.</p><pre><code class="language-julia"># define our toy color model
struct MyRGB
    r::UInt8
    b::UInt8
    g::UInt8
end</code></pre><p>Note how we defined our new toy color model as <code>struct</code>. Because of this and the fact that all its components are bit types (in this case <code>UInt8</code>), any instantiation of our new type will be represented as a continuous block of memory as well.</p><p>We can now apply our color model to our <code>memory</code> vector from above, and interpret the underlying memory as a vector of to <code>MyRGB</code> values instead.</p><pre><code class="language-julia-repl">julia&gt; reinterpret(MyRGB, memory)
2-element Vector{MyRGB}:
 MyRGB(0x01,0x02,0x03)
 MyRGB(0x04,0x05,0x06)</code></pre><p>Similar to the <code>UInt16</code> example, we now group neighboring bytes into larger units (namely <code>MyRGB</code>). In contrast to the <code>UInt16</code> example we are still able to access the individual components underneath. This simple toy color model already allows us to do a lot of useful things. We could define functions that work on <code>MyRGB</code> values in a color-space appropriate fashion. We could also define other color models and implement function to convert between them.</p><p>However, our little toy color model is not yet optimal. For example it hard-codes a predefined color depth of 24 bit. We may have use-cases where we need a richer color space. One thing we could do to achieve that would be to introduce a new type in similar fashion. Still, because they have a different range of available numbers per channel (because they have a different amount of bits per channel), we would have to write a lot of specialized code to be able to appropriately handle all color models and depth.</p><p>Luckily, the creators of <code>ColorTypes.jl</code> went a with a more generic strategy: Using parameterized types and <strong>fixed point numbers</strong>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If you are interested in how various color models are actually designed and/or implemented in Julia, you can take a look at the <a href="https://github.com/JuliaGraphics/ColorTypes.jl">ColorTypes.jl</a> package.</p></div></div><h2 id="Fixed-Point-Numbers"><a class="docs-heading-anchor" href="#Fixed-Point-Numbers">Fixed Point Numbers</a><a id="Fixed-Point-Numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-Point-Numbers" title="Permalink"></a></h2><p>The idea behind using fixed point numbers for each color component is fairly simple. No matter how many bits a component is made up of, we always want the largest possible value of the component to be equal to <code>1.0</code> and the smallest possible value to be equal to <code>0</code>. Of course, the amount of possible intermediate numbers still depends on the number of underlying bits in the memory, but that is not much of an issue.</p><pre><code class="language-julia-repl">julia&gt; using ImageCore; # ImageCore reexports FixedPointNumbers and Colors

julia&gt; reinterpret(N0f8, 0xFF)
1.0N0f8

julia&gt; reinterpret(N0f16, 0xFFFF)
1.0N0f16</code></pre><p>Not only does this allow for simple conversion between different color depths, it also allows us to implement generic algorithms, that are completely agnostic to the utilized color depth.</p><p>It is worth pointing out again, that we get all these goodies without actually changing or copying the original memory block. Remember how during this whole tutorial we have only changed the interpretation of some underlying memory, and have not had the need to copy any data so far.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>For pixel data we are mainly interested in <strong>unsigned</strong> fixed point numbers, but there are others too. Check out the package <a href="https://github.com/JuliaMath/FixedPointNumbers.jl">FixedPointNumbers.jl</a> for more information on fixed point numbers in general.</p></div></div><p>Let us now leave our toy model behind and use the actual implementation of <code>RGB</code> on our example vector <code>memory</code>. With the first command we will interpret our data as two pixels with 8 bit per color channel, and with the second command as a single pixel of 16 bit per color channel</p><pre><code class="language-julia-repl">julia&gt; reinterpret(RGB{N0f8}, memory)
2-element reinterpret(RGB{N0f8}, ::Vector{UInt8}):
 RGB{N0f8}(0.004,0.008,0.012)
 RGB{N0f8}(0.016,0.02,0.024)

julia&gt; reinterpret(RGB{N0f16}, memory)
1-element reinterpret(RGB{N0f16}, ::Vector{UInt8}):
 RGB{N0f16}(0.00783,0.01567,0.02351)</code></pre><p>Note how the values are now interpreted as floating point numbers.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../background/">« Background and Motivation</a><a class="docs-footer-nextpage" href="../interface/">High-level Interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 8 August 2021 02:16">Sunday 8 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
