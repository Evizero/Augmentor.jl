<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>High-level Interface · Augmentor.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/style.css" rel="stylesheet" type="text/css"/><link href="../democards/gridtheme.css" rel="stylesheet" type="text/css"/><link href="../democards/listtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Augmentor.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Augmentor.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started</a></li><li><span class="tocitem">Introduction and Motivation</span><ul><li><a class="tocitem" href="../background/">Background and Motivation</a></li><li><a class="tocitem" href="../images/">Working with Images in Julia</a></li></ul></li><li><span class="tocitem">User&#39;s Guide</span><ul><li class="is-active"><a class="tocitem" href>High-level Interface</a><ul class="internal"><li><a class="tocitem" href="#pipeline"><span>Defining a Pipeline</span></a></li><li><a class="tocitem" href="#The-design-behind-operation-types"><span>The design behind operation types</span></a></li><li><a class="tocitem" href="#Loading-the-Example-Image"><span>Loading the Example Image</span></a></li><li><a class="tocitem" href="#Augmenting-an-Image"><span>Augmenting an Image</span></a></li><li><a class="tocitem" href="#Augmenting-Image-Batches"><span>Augmenting Image Batches</span></a></li></ul></li><li><a class="tocitem" href="../operations/">Supported Operations</a></li></ul></li><li><a class="tocitem" href="../examples/">Tutorials</a></li><li><a class="tocitem" href="../LICENSE/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User&#39;s Guide</a></li><li class="is-active"><a href>High-level Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>High-level Interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Evizero/Augmentor.jl/blob/master/docs/src/interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="High-level-Interface"><a class="docs-heading-anchor" href="#High-level-Interface">High-level Interface</a><a id="High-level-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#High-level-Interface" title="Permalink"></a></h1><p>Integrating Augmentor into an existing project should in general not require any major changes to your code. In most cases it should break down to the three basic steps outlined below. We will spend the rest of this document investigating these in more detail.</p><ol><li><p>Import Augmentor into the namespace of your program.</p><pre><code class="language-julia">using Augmentor</code></pre></li><li><p>Define a (stochastic) image processing pipeline by chaining the desired <a href="../operations/#operations">operations</a> using <code>|&gt;</code> and <code>*</code>.</p><pre><code class="language-julia-repl">julia&gt; pl = FlipX() * FlipY() |&gt; Zoom(0.9:0.1:1.2) |&gt; CropSize(64,64)
3-step Augmentor.ImmutablePipeline:
 1.) Either: (50%) Flip the X axis. (50%) Flip the Y axis.
 2.) Zoom by I ∈ {0.9×0.9, 1.0×1.0, 1.1×1.1, 1.2×1.2}
 3.) Crop a 64×64 window around the center</code></pre></li><li><p>Apply the pipeline to the existing image or set of images.</p><pre><code class="language-julia">img_processed = augment(img_original, pl)</code></pre></li></ol><p>Depending on the complexity of your problem, you may want to iterate between step <code>2.</code> and <code>3.</code> to identify an appropriate pipeline. Take a look at the <a href="../examples/examples/mnist_elastic/#mnist_elastic">Elastic Distortions Tutorial</a> for an example of how such an iterative process could look like.</p><h2 id="pipeline"><a class="docs-heading-anchor" href="#pipeline">Defining a Pipeline</a><a id="pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#pipeline" title="Permalink"></a></h2><p>In Augmentor, a (stochastic) image-processing pipeline can be understood as a sequence of operations, for which the parameters can (but need not) be random variables. What that essentially means is that the user explicitly specifies which image operation to perform in what order. A complete list of available operations can be found at <a href="../operations/#operations">Supported Operations</a>.</p><p>To start off with a simple example, let us assume that we want to first rotate our image(s) counter-clockwise by 14°, then crop them down to the biggest possible square, and lastly resize the image(s) to a fixed size of 64 by 64 pixel. Such a pipeline would be defined as follows:</p><pre><code class="language-julia-repl">julia&gt; pl = Rotate(14) |&gt; CropRatio(1) |&gt; Resize(64,64)
3-step Augmentor.ImmutablePipeline:
 1.) Rotate 14 degree
 2.) Crop to 1:1 aspect ratio
 3.) Resize to 64×64</code></pre><p>Notice that in the example above there is no room for randomness. In other words, the same input image would always result in the same output image given that pipeline. If we wish for more variation we can do so by using a vector as our parameters, instead of a single number.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In this subsection we will focus only on how to define a pipeline, without actually thinking too much about how to apply that pipeline to an actual image. The later will be the main topic of the rest of this document.</p></div></div><p>Say we wish to adapt our pipeline such that the rotation is a little more random. More specifically, lets say we want our image to be rotated by either -10°, -5°, 5°, 10°, or not at all. Other than that change we will leave the rest of the pipeline as is.</p><pre><code class="language-julia-repl">julia&gt; pl = Rotate([-10,-5,0,5,10]) |&gt; CropRatio(1) |&gt; Resize(64,64)
3-step Augmentor.ImmutablePipeline:
 1.) Rotate by θ ∈ [-10, -5, 0, 5, 10] degree
 2.) Crop to 1:1 aspect ratio
 3.) Resize to 64×64</code></pre><p>Variation in the parameters is only one of the two main ways to introduce randomness to our pipeline. Additionally, one can specify that an operation should be sampled randomly from a chosen set of operations . This can be accomplished using a utility operation called <a href="../operations/misc/utilities/#Augmentor.Either"><code>Either</code></a>, which has its own convenience syntax.</p><p>As an example, let us assume we wish to first either mirror our image(s) horizontally, or vertically, or not at all, and then crop it down to a size of 100 by 100 pixel around the image&#39;s center. We can specify the &quot;either&quot; using the <code>*</code> operator.</p><pre><code class="language-julia-repl">julia&gt; pl = FlipX() * FlipY() * NoOp() |&gt; CropSize(100,100)
2-step Augmentor.ImmutablePipeline:
 1.) Either: (33%) Flip the X axis. (33%) Flip the Y axis. (33%) No operation.
 2.) Crop a 100×100 window around the center</code></pre><p>It is also possible to specify the odds of for such an &quot;either&quot;. For example we may want the <a href="../operations/misc/utilities/#Augmentor.NoOp"><code>NoOp</code></a> to be twice as likely as either of the mirroring options.</p><pre><code class="language-julia-repl">julia&gt; pl = (1=&gt;FlipX()) * (1=&gt;FlipY()) * (2=&gt;NoOp()) |&gt; CropSize(100,100)
2-step Augmentor.ImmutablePipeline:
 1.) Either: (25%) Flip the X axis. (25%) Flip the Y axis. (50%) No operation.
 2.) Crop a 100×100 window around the center</code></pre><p>Now that we know how to define a pipeline, let us think about how to apply it to an image or a set of images.</p><h2 id="The-design-behind-operation-types"><a class="docs-heading-anchor" href="#The-design-behind-operation-types">The design behind operation types</a><a id="The-design-behind-operation-types-1"></a><a class="docs-heading-anchor-permalink" href="#The-design-behind-operation-types" title="Permalink"></a></h2><p>The purpose of an operation is to simply serve as a &quot;dumb placeholder&quot; to specify the intent and parameters of the desired transformation. What that means is that a pipeline of operations can be thought of as a list of instructions (a cookbook of sorts), that Augmentor uses internally to construct the required code that implements the desired behaviour in the most efficient way it can.</p><p>The way an operation is implemented depends on the rest of the specified pipeline. For example, Augmentor knows three different ways to implement the behaviour of the operation <code>Rotate90</code> and will choose the one that best coincides with the other operations of the pipeline and their concrete order.</p><ol><li><p>Call the function <code>rotl90</code> of Julia&#39;s base library, which makes use of the fact that a 90 degree rotation can be implemented very efficiently. While by itself this is the fastest way to compute the result, this function is &quot;eager&quot; and will allocate a new array. If <code>Rotate90</code> is followed by another operation this may not be the best choice, since it will cause a temporary image that is later discarded.</p></li><li><p>Create a <code>SubArray</code> of a <code>PermutedDimsArray</code>. This is more or less a lazy version of <code>rotl90</code> that makes use of the fact that a 90 degree rotation can be described 1-to-1 using just the original pixels. By itself this strategy is slower than <code>rotl90</code>, but if it is followed by an operation such as <code>Crop</code> or <code>CropSize</code> it can be significantly faster. The reason for this is that it avoids the computation of unused pixels and also any allocation of temporary memory. The computation overhead per output pixel, while small, grows linearly with the number of chained operations.</p></li><li><p>Create an <code>AffineMap</code> using a rotation matrix that describes a 90 degree rotation around the center of the image. This will result in a lazy transformation of the original image that is further compose-able with other <code>AffineMap</code>. This is the slowest available strategy, unless multiple affine operations are chained together. If that is the case, then chaining the operations can be reduced to composing the tiny affine maps instead. This effectively fuses multiple operations into a single operation for which the computation overhead per output pixel remains approximately constant in respect to the number of chained operations.</p></li></ol><h2 id="Loading-the-Example-Image"><a class="docs-heading-anchor" href="#Loading-the-Example-Image">Loading the Example Image</a><a id="Loading-the-Example-Image-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-the-Example-Image" title="Permalink"></a></h2><p>Augmentor ships with a custom example image, which was specifically designed for visualizing augmentation effects. It can be accessed by calling the function <code>testpattern()</code>. That said, doing so explicitly should rarely be necessary in practice, because most high-level functions will default to using <code>testpattern()</code> if no other image is specified.</p><article class="docstring"><header><a class="docstring-binding" id="Augmentor.testpattern" href="#Augmentor.testpattern"><code>Augmentor.testpattern</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">testpattern([T=RGBA{N0f8}]; ratio=1.0) -&gt; Matrix{RGBA{N0f8}}</code></pre><p>Load and return the provided 300x400 test image. Additional args and kwargs are passed to <code>imresize</code>.</p><p>The returned image was specifically designed to be informative about the effects of the applied augmentation operations. It is thus well suited to prototype an augmentation pipeline, because it makes it easy to see what kind of effects one can achieve with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Evizero/Augmentor.jl/blob/3c62635457395def90c63690847aa8a26d104b49/src/utils.jl#L1-L11">source</a></section></article><pre><code class="language-julia">using Augmentor
img = testpattern()</code></pre><p><img src="../assets/big_pattern.png" alt="testpattern"/></p><h2 id="Augmenting-an-Image"><a class="docs-heading-anchor" href="#Augmenting-an-Image">Augmenting an Image</a><a id="Augmenting-an-Image-1"></a><a class="docs-heading-anchor-permalink" href="#Augmenting-an-Image" title="Permalink"></a></h2><p>Once a pipeline is constructed it can be applied to an image (i.e. <code>AbstractArray{&lt;:ColorTypes.Colorant}</code>), or even just to an array of numbers (i.e. <code>AbstractArray{&lt;:Number}</code>), using the function <code>augment</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Augmentor.augment" href="#Augmentor.augment"><code>Augmentor.augment</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">augment([img], pipeline) -&gt; out</code></pre><p>Apply the operations of the given <code>pipeline</code> sequentially to the given image <code>img</code> and return the resulting image <code>out</code>.</p><pre><code class="language-julia-repl">julia&gt; img = testpattern();

julia&gt; out = augment(img, FlipX() |&gt; FlipY())
3×2 Array{Gray{N0f8},2}:
[...]</code></pre><p>The parameter <code>img</code> can either be a single image, or a tuple of multiple images. In case <code>img</code> is a tuple of images, its elements will be assumed to be conceptually connected. Consequently, all images in the tuple will take the exact same path through the pipeline; even when randomness is involved. This is useful for the purpose of image segmentation, for which the input and output are both images that need to be transformed exactly the same way.</p><pre><code class="language-julia">img1 = testpattern()
img2 = Gray.(testpattern())
out1, out2 = augment((img1, img2), FlipX() |&gt; FlipY())</code></pre><p>The parameter <code>pipeline</code> can be a <code>Augmentor.Pipeline</code>, a tuple of <code>Augmentor.Operation</code>, or a single <code>Augmentor.Operation</code>.</p><pre><code class="language-julia">img = testpattern()
augment(img, FlipX() |&gt; FlipY())
augment(img, (FlipX(), FlipY()))
augment(img, FlipX())</code></pre><p>If <code>img</code> is omitted, Augmentor will use the augmentation test image provided by the function <a href="#Augmentor.testpattern"><code>testpattern</code></a> as the input image.</p><pre><code class="language-julia">augment(FlipX())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Evizero/Augmentor.jl/blob/3c62635457395def90c63690847aa8a26d104b49/src/augment.jl#L1-L46">source</a></section></article><p>We also provide a mutating version of <code>augment</code> that writes the output into preallocated memory. While this function avoids allocation, it does have the caveat that the size of the output image must be known beforehand (and thus must not be random).</p><article class="docstring"><header><a class="docstring-binding" id="Augmentor.augment!" href="#Augmentor.augment!"><code>Augmentor.augment!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">augment!(out, img, pipeline) -&gt; out</code></pre><p>Apply the operations of the given <code>pipeline</code> sequentially to the image <code>img</code> and write the resulting image into the preallocated parameter <code>out</code>. For convenience <code>out</code> is also the function&#39;s return-value.</p><pre><code class="language-julia">img = testpattern()
out = similar(img)
augment!(out, img, FlipX() |&gt; FlipY())</code></pre><p>The parameter <code>img</code> can either be a single image, or a tuple of multiple images. In case <code>img</code> is a tuple of images, the parameter <code>out</code> has to be a tuple of the same length and ordering. See <a href="#Augmentor.augment"><code>augment</code></a> for more information.</p><pre><code class="language-julia">imgs = (testpattern(), Gray.(testpattern()))
outs = (similar(imgs[1]), similar(imgs[2]))
augment!(outs, imgs, FlipX() |&gt; FlipY())</code></pre><p>The parameter <code>pipeline</code> can be a <code>Augmentor.Pipeline</code>, a tuple of <code>Augmentor.Operation</code>, or a single <code>Augmentor.Operation</code>.</p><pre><code class="language-julia">img = testpattern()
out = similar(img)
augment!(out, img, FlipX() |&gt; FlipY())
augment!(out, img, (FlipX(), FlipY()))
augment!(out, img, FlipX())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Evizero/Augmentor.jl/blob/3c62635457395def90c63690847aa8a26d104b49/src/augment.jl#L73-L108">source</a></section></article><h2 id="Augmenting-Image-Batches"><a class="docs-heading-anchor" href="#Augmenting-Image-Batches">Augmenting Image Batches</a><a id="Augmenting-Image-Batches-1"></a><a class="docs-heading-anchor-permalink" href="#Augmenting-Image-Batches" title="Permalink"></a></h2><p>In most machine learning scenarios we will want to process a whole batch of images at once, instead of a single image at a time. For this reason we provide the function <code>augmentbatch!</code>, which also supports multi-threading.</p><article class="docstring"><header><a class="docstring-binding" id="Augmentor.augmentbatch!" href="#Augmentor.augmentbatch!"><code>Augmentor.augmentbatch!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">augmentbatch!([resource], outs, imgs, pipeline, [obsdim]) -&gt; outs</code></pre><p>Apply the operations of the given <code>pipeline</code> to the images in <code>imgs</code> and write the resulting images into <code>outs</code>.</p><p>Both <code>outs</code> and <code>imgs</code> have to contain the same number of images. Each of these two variables can either be in the form of a higher dimensional array, in the form of a vector of arrays for which each vector element denotes an image.</p><pre><code class="language-julia"># create five example observations of size 3x3
imgs = rand(3,3,5)
# create output arrays of appropriate shape
outs = similar(imgs)
# transform the batch of images
augmentbatch!(outs, imgs, FlipX() |&gt; FlipY())</code></pre><p>If one (or both) of the two parameters <code>outs</code> and <code>imgs</code> is a higher dimensional array, then the optional parameter <code>obsdim</code> can be used specify which dimension denotes the observations (defaults to <code>ObsDim.Last()</code>),</p><pre><code class="language-julia"># create five example observations of size 3x3
imgs = rand(5,3,3)
# create output arrays of appropriate shape
outs = similar(imgs)
# transform the batch of images
augmentbatch!(outs, imgs, FlipX() |&gt; FlipY(), ObsDim.First())</code></pre><p>Similar to <a href="#Augmentor.augment!"><code>augment!</code></a>, it is also allowed for <code>outs</code> and <code>imgs</code> to both be tuples of the same length. If that is the case, then each tuple element can be in any of the forms listed above. This is useful for tasks such as image segmentation, where each observations is made up of more than one image.</p><pre><code class="language-julia"># create five example observations where each observation is
# made up of two conceptually linked 3x3 arrays
imgs = (rand(3,3,5), rand(3,3,5))
# create output arrays of appropriate shape
outs = similar.(imgs)
# transform the batch of images
augmentbatch!(outs, imgs, FlipX() |&gt; FlipY())</code></pre><p>The parameter <code>pipeline</code> can be a <code>Augmentor.Pipeline</code>, a tuple of <code>Augmentor.Operation</code>, or a single <code>Augmentor.Operation</code>.</p><pre><code class="language-julia">augmentbatch!(outs, imgs, FlipX() |&gt; FlipY())
augmentbatch!(outs, imgs, (FlipX(), FlipY()))
augmentbatch!(outs, imgs, FlipX())</code></pre><p>The optional first parameter <code>resource</code> can either be <code>CPU1()</code> (default) or <code>CPUThreads()</code>. In the later case the images will be augmented in parallel. For this to make sense make sure that the environment variable <code>JULIA_NUM_THREADS</code> is set to a reasonable number so that <code>Threads.nthreads()</code> is greater than 1.</p><pre><code class="language-julia"># transform the batch of images in parallel using multithreading
augmentbatch!(CPUThreads(), outs, imgs, FlipX() |&gt; FlipY())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Evizero/Augmentor.jl/blob/3c62635457395def90c63690847aa8a26d104b49/src/augmentbatch.jl#L10-L79">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../images/">« Working with Images in Julia</a><a class="docs-footer-nextpage" href="../operations/">Supported Operations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 2 August 2021 12:34">Monday 2 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
